# 배운 내용

### useMemo & useCallback

> useMemo 사용

```JS
const onSearch = e => {
    debouncedSearch(e.target.value);
  };

  const debouncedSearch = useMemo(
    () =>
      debounce(query => {
        setQuery(query);
      }, 200),
    []
  );


  return (
        <input
          className="channel-search__input__text"
          onChange={onSearch}
          placeholder="Search people, company, message"
          type="text"
        />
  )
```

- debounce를 적용시키기 전에 setQuery를 이용해 e.target.value를 읽으니, API호출이 한 자마다 전송되서 결국 429에러가 발생함.
  - debounce를 적용한 후 input e.target.value가 모두 작성된 후 0.2초 후에 API 전송되도록 변경시키니 429 에러가 발생하지 않음.
- useMemo를 통해 메모이제이션을 구현해봤음
  - debounce를 이용해서 429에러를 해결하는 것에만 멈췄어도 됬었지만, chat창에 chatting이 발생할 때마다 렌더링이 일어나고 debounce를 계속 렌더링 될 때마다 전송되는게 아닐까? input의 onChange가 변경된게 없다면 useMemo를 통해 최적화를 시켜줘도 좋겠다는 생각에 useMemo로 감싸줌.
