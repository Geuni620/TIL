# 모던자바스크립트 Deep Dive

## 11장 원시 값과 객체의 비교

원시타입 의 값, 즉 원시 값은 변경 불가능한 값.  
객체(참조) 타입의 값, 즉 객체는 변경 가능한 값.

<br>

### 11.1 원시 값

---

- 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름.  
  값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과를 말함.
- 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술.

<br>

### 11.1.1 변경 불가능한 값

---

불변성

- 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소가 변경됨.
- 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법은 없음.

<br>

### 11.1.2 문자열과 불변성

---

```
var str = `Hello`;
str = `world`;
```

1. 첫 번째 문이 실행되면 문자열 `Hello`가 생성되고 문자열 `Hello`가 저장된 메모리 공간의 첫 번째 메모리 셀 주소를 가리킴
2. 두 번째 문이 실행되면 이전에 생성된 문자열 `Hello`를 수정하는 것이 아니라, 새로운 문자열 `world`를 메모리에 생성하고 식별자 str은 이것을 가리킴

   **이때 문자열 `Hello`와 `world`는 모두 메모리에 존재함**

<br>

**유사 배열 객체**

- 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있음
- length 프로퍼티를 갖는 객체를 말함
- 문자여은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며, length 프로퍼티를 갖기 때문에 **유사 배열 객체**이고, for문으로 순회할 수 있음

```
var str = `string`;

console.log(str[0]); // s
```

```
var str = `string`;

//문자열은 원시 값이므로 변경할 수 없음
//이때 에러가 발생하지도 않음
str[0] = `S`;

console.log(str); // string
```

<br>

### 11.1.3 값에 의한 전달

> 얕은 복사의 개념

---

```
var score = 80;
var copy = score;

console.log(score, copy) // 80 80
console.log(score === copy) // true


score = 100;
console.log(score, copy) // 100 80
```

- score 변수와 copy 변수의 값 80은 **다른 메모리 공간에 저장된 별개의 값**이다.

* score 변수 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않음.

<br>

**식별자**

- 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름.
- 값은 메모리 공간에 저장되어 있음.

* 따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해 낼수 있어야 함  
  → 이를 위해 변수와 같은 식별자는 값이 아니라 **메모리 주소**를 기억하고 있음.  
  → 식별자는 메모리 주소에 붙인 이름이라고 할 수 있음.

<br>

**값에 의한 전달**

원시 값을 갖는 변수를 할당하면 변수 할당 시점이든, 두 변수 중 어느 하나의 변수에 값을 재할당하는 시점이든, 결국 두 변수의 원시값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에 재할당을 통해 값을 변경하더라도 **서로 간섭 할수 없음**.

<br>

### 11.2 객체

---

- 객체는 프로퍼티의 개수가 정해져 있지 않음.
- 동적으로 추가되고 삭제할 수 있음.
- 프로퍼티의 값에 제약이 없음.  
  → 따라서, 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없음.

### 11.2.1 변경 가능한 값

---

- 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값.
- 재할당 없이 프로퍼티를 동적으로 추가할 수 있음.
- 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있음.

```
var person = {
  name : `Lee`
};
```

- *원시 값을 할당한 변수*가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시 값에 접근 가능.  
  → 즉, 원시 값을 할당한 변수는 원시 값 자체를 값으로 가짐
- *객체를 할당한 변수*가 기억하는 메모리주소를 통해 메모리 공간에 접근하면 **참조 값**에 접근할 수 있음.  
  → 즉 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근.

* 객체는 변경 가능한 값.

  - 따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있음.

  - 재할당 없이 프로퍼티를 동적으로 추가할 수 있고 프로퍼티 값을 갱신, 프로퍼티 자체를 삭제할 수도 있음.

```
var person = {
  name: `Lee`
};

//프로퍼티 값 갱신
person.name = `Kim`

//프로퍼티 동적 생성
person.address = `Seoul`

console.log(person) // { name: 'Kim', address: 'Seoul' }
```

- 객체를 변경할 때마다 원시 값처럼 이전 값을 복사해서 새롭게 생성한다면 객체 크기가 매우 클 수도 있고, 원시 값처럼 크기가 일정하지 않으며 프로퍼티 값이 객체 일 수도 있어서(중첩) 복사해서 생성하는 비용이 많아짐.
  - 즉, 메모리 효율적 소비가 어렵고 성능이 나빠짐  
    → 따라서 객체는 변경 가능한 값으로 설계 됨.

<br>

### 11.2.2 참조에 의한 전달

> 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이 무엇을 의미하는지, 이로 인해 어떤 부작용이 발생하는지 확인해보기

---

```
var person = {
  name: `Lee`
};

//참조 값을 복사(얕은 복사)
var copy = person;
```

- 원본 person은 사본 copy에 할당하면 원본 person의 참조 값을 복사해서 copy에 저장.
- 원본 person과 사본 copy는 저장된 메모리 주소는 다르지만 동일한 참조 값을 가짐.  
  → 원본 person과 사본 copy 모두 동일한 객체를 가리킴.  
  → 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받음.

```
copy.name =`Kim`;
person.address = `Seoul`;

console.log(person) // { name: 'Kim', address: 'Seoul' }
console.log(copy) // { name: 'Kim', address: 'Seoul' }
```

  <br>

**얕은 복사와 깊은 복사**

- 얕은복사
  객체를 프로퍼티 값으로 갖는 객체의 경우, 한 단계까지만 복사하는 것.

* 깊은복사
  객체에 중첩되어 있는 개체까지 모두 복사하는 것.

**얕은 복사와 깊은 복사 차이점**

- 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체임.
  즉, 원본과 복사본은 참조 값이 다른 별개의 객체

  - 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조 값을 복사.

  * 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본을 만듦.

<br>
